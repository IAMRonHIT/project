<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Believable Robot</title>
    <style>
        /* Basic styling for the body and canvas */
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            font-family: 'Inter', sans-serif; /* Use Inter font */
            background-color: #f0f0f0; /* Light gray background */
        }
        canvas {
            display: block; /* Remove default inline spacing */
            width: 100%;   /* Make canvas fill width */
            height: 100%;  /* Make canvas fill height */
        }
        /* Style for a simple message overlay */
        #message {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            display: none; /* Hidden by default */
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="message">Use your mouse to rotate and zoom!</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // === Global Variables ===
        let scene, camera, renderer, robot, controls;

        // === Initialization Function ===
        function init() {
            // --- Scene Setup ---
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xadd8e6); // Light blue background

            // --- Camera Setup ---
            // PerspectiveCamera(field of view, aspect ratio, near clipping plane, far clipping plane)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 6, 10); // Set initial camera position

            // --- Renderer Setup ---
            renderer = new THREE.WebGLRenderer({ antialias: true }); // Enable anti-aliasing for smoother edges
            renderer.setSize(window.innerWidth, window.innerHeight); // Set renderer size to window size
            renderer.shadowMap.enabled = true; // Enable shadows
            document.body.appendChild(renderer.domElement); // Add the renderer's canvas element to the DOM

            // --- Lighting ---
            // Ambient light: Illuminates all objects in the scene equally
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // Soft white light
            scene.add(ambientLight);

            // Directional light: Emits light in a specific direction (like the sun)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7.5); // Position the light
            directionalLight.castShadow = true; // Allow this light to cast shadows
            // Configure shadow properties for better quality
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            scene.add(directionalLight);

            // --- Floor ---
            const floorGeometry = new THREE.PlaneGeometry(50, 50); // Large plane
            const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x808080, side: THREE.DoubleSide }); // Gray color
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2; // Rotate the plane to be horizontal
            floor.position.y = -2; // Position it below the robot
            floor.receiveShadow = true; // Allow the floor to receive shadows
            scene.add(floor);

            // --- Create Robot ---
            robot = createRobot();
            robot.position.y = -0.5; // Adjust robot's vertical position to stand on the floor plane
            scene.add(robot);

            // --- Controls ---
            // OrbitControls allow the camera to orbit around a target
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // Enable damping (inertia) for smoother interaction
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false; // Prevent panning in screen space
            controls.maxPolarAngle = Math.PI / 2; // Limit vertical rotation (don't go below the floor)
            controls.target.set(0, 1.5, 0); // Set the point the camera looks at (center of the robot)
            controls.update(); // Must be called after any manual changes to the camera's transform

            // --- Show Interaction Message ---
            const messageDiv = document.getElementById('message');
            if (messageDiv) {
                messageDiv.style.display = 'block';
                setTimeout(() => { messageDiv.style.display = 'none'; }, 5000); // Hide after 5 seconds
            }

            // --- Handle Window Resize ---
            window.addEventListener('resize', onWindowResize, false);
        }

        // === Create Robot Function ===
        function createRobot() {
            // Create a group to hold all parts of the robot
            const robotGroup = new THREE.Group();

            // Define materials
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x4444ff, roughness: 0.4, metalness: 0.6 }); // Metallic blue
            const limbMaterial = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.6, metalness: 0.4 }); // Metallic gray
            const jointMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.8, metalness: 0.2 }); // Lighter gray for joints
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.5, metalness: 0.5 }); // Silver head
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x550000 }); // Red glowing eyes

            // --- Torso ---
            const torsoGeometry = new THREE.BoxGeometry(2, 3, 1); // width, height, depth
            const torso = new THREE.Mesh(torsoGeometry, bodyMaterial);
            torso.castShadow = true;
            torso.position.y = 1.5; // Position torso center
            robotGroup.add(torso);

            // --- Head ---
            const headGeometry = new THREE.BoxGeometry(1.2, 1, 1);
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.castShadow = true;
            head.position.y = 3.5; // Position head above torso
            robotGroup.add(head);

            // --- Eyes ---
            const eyeGeometry = new THREE.SphereGeometry(0.15, 16, 16);
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.3, 3.7, 0.55); // x, y, z position relative to robot group center
            robotGroup.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.3, 3.7, 0.55);
            robotGroup.add(rightEye);

            // --- Neck (simple cylinder) ---
            const neckGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.5, 16);
            const neck = new THREE.Mesh(neckGeometry, jointMaterial);
            neck.castShadow = true;
            neck.position.y = 3.0; // Between head and torso
            robotGroup.add(neck);

            // --- Arms (Left and Right) ---
            // Function to create an arm (upper, lower, joint)
            const createArm = (isLeft) => {
                const armGroup = new THREE.Group();
                const side = isLeft ? 1 : -1; // Multiplier for positioning

                // Shoulder Joint
                const shoulderGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                const shoulder = new THREE.Mesh(shoulderGeometry, jointMaterial);
                shoulder.castShadow = true;
                shoulder.position.set(side * 1.3, 2.6, 0);
                armGroup.add(shoulder);

                // Upper Arm
                const upperArmGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.5, 16);
                const upperArm = new THREE.Mesh(upperArmGeometry, limbMaterial);
                upperArm.castShadow = true;
                upperArm.position.set(side * 1.3, 1.8, 0); // Position below shoulder
                armGroup.add(upperArm);

                // Elbow Joint
                const elbowGeometry = new THREE.SphereGeometry(0.35, 16, 16);
                const elbow = new THREE.Mesh(elbowGeometry, jointMaterial);
                elbow.castShadow = true;
                elbow.position.set(side * 1.3, 1.0, 0); // Position below upper arm
                armGroup.add(elbow);

                // Lower Arm
                const lowerArmGeometry = new THREE.CylinderGeometry(0.25, 0.25, 1.2, 16);
                const lowerArm = new THREE.Mesh(lowerArmGeometry, limbMaterial);
                lowerArm.castShadow = true;
                lowerArm.position.set(side * 1.3, 0.3, 0); // Position below elbow
                armGroup.add(lowerArm);

                return armGroup;
            };

            const leftArm = createArm(true);
            const rightArm = createArm(false);
            robotGroup.add(leftArm);
            robotGroup.add(rightArm);

            // --- Legs (Left and Right) ---
             // Function to create a leg (upper, lower, joint)
            const createLeg = (isLeft) => {
                const legGroup = new THREE.Group();
                const side = isLeft ? 1 : -1; // Multiplier for positioning

                // Hip Joint
                const hipGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const hip = new THREE.Mesh(hipGeometry, jointMaterial);
                hip.castShadow = true;
                hip.position.set(side * 0.6, 0, 0);
                legGroup.add(hip);

                // Upper Leg
                const upperLegGeometry = new THREE.CylinderGeometry(0.4, 0.4, 1.5, 16);
                const upperLeg = new THREE.Mesh(upperLegGeometry, limbMaterial);
                upperLeg.castShadow = true;
                upperLeg.position.set(side * 0.6, -0.8, 0); // Position below hip
                legGroup.add(upperLeg);

                // Knee Joint
                const kneeGeometry = new THREE.SphereGeometry(0.45, 16, 16);
                const knee = new THREE.Mesh(kneeGeometry, jointMaterial);
                knee.castShadow = true;
                knee.position.set(side * 0.6, -1.6, 0); // Position below upper leg
                legGroup.add(knee);

                // Lower Leg
                const lowerLegGeometry = new THREE.CylinderGeometry(0.35, 0.35, 1.4, 16);
                const lowerLeg = new THREE.Mesh(lowerLegGeometry, limbMaterial);
                lowerLeg.castShadow = true;
                lowerLeg.position.set(side * 0.6, -2.4, 0); // Position below knee
                legGroup.add(lowerLeg);

                 // Foot
                const footGeometry = new THREE.BoxGeometry(0.7, 0.3, 1.2); // width, height, depth
                const foot = new THREE.Mesh(footGeometry, jointMaterial);
                foot.castShadow = true;
                foot.position.set(side * 0.6, -3.2, 0.2); // Position below lower leg, slightly forward
                legGroup.add(foot);


                return legGroup;
            };

            const leftLeg = createLeg(true);
            const rightLeg = createLeg(false);
            robotGroup.add(leftLeg);
            robotGroup.add(rightLeg);

            // --- Antenna ---
            const antennaBaseGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.3, 8);
            const antennaBase = new THREE.Mesh(antennaBaseGeometry, jointMaterial);
            antennaBase.position.set(0, 4.15, 0); // Top of head
            robotGroup.add(antennaBase);

            const antennaRodGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.8, 8);
            const antennaRod = new THREE.Mesh(antennaRodGeometry, limbMaterial);
            antennaRod.position.set(0, 4.6, 0); // Above base
            robotGroup.add(antennaRod);

            const antennaTipGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const antennaTip = new THREE.Mesh(antennaTipGeometry, eyeMaterial); // Use eye material for tip
            antennaTip.position.set(0, 5.0, 0); // Top of rod
            robotGroup.add(antennaTip);


            // Enable shadows for all robot parts recursively
             robotGroup.traverse(function(node) {
                if (node instanceof THREE.Mesh) {
                    node.castShadow = true;
                    node.receiveShadow = false; // Robot parts generally don't receive shadows from themselves in this simple setup
                }
            });


            return robotGroup;
        }

        // === Handle Window Resize ===
        function onWindowResize() {
            // Update camera aspect ratio
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix(); // Apply the changes

            // Update renderer size
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // === Animation Loop ===
        function animate() {
            // Request the next frame
            requestAnimationFrame(animate);

            // Update controls (needed if damping or auto-rotate is enabled)
            controls.update();

            // Render the scene from the perspective of the camera
            renderer.render(scene, camera);
        }

        // === Start the application ===
        // Use window.onload to ensure everything is loaded before starting Three.js
        window.onload = function() {
            try {
                init();
                animate();
            } catch (error) {
                console.error("Failed to initialize Three.js:", error);
                // Display a user-friendly error message
                const errorDiv = document.createElement('div');
                errorDiv.id = 'message'; // Reuse message style
                errorDiv.style.display = 'block';
                errorDiv.style.backgroundColor = 'rgba(255, 0, 0, 0.7)'; // Red background for error
                errorDiv.textContent = 'Error initializing 3D view. Please check console.';
                document.body.appendChild(errorDiv);
            }
        };

    </script>
</body>
</html>
